# SPRING

### JPQL

- JPQL(Java Persistence Query Language)은 Java Persistence API (JPA)의 일부로서 사용되는 데이터베이스 질의 언어입니다.
- JPQL은 객체 지향 프로그래밍 언어인 자바와 관계형 데이터베이스 사이의 데이터 검색, 필터링 및 조작을 수행하는 데 사용됩니다.
- JPQL은 SQL(Structured Query Language)과 비슷한 문법을 가지며, 데이터베이스 테이블 대신 JPA 엔티티와 관련된 개체를 대상으로 쿼리를 작성합니다.
- **엔티티를 대상으로 쿼리**: JPQL은 JPA 엔티티 클래스를 대상으로 작성됩니다. 이 클래스들은 관계형 데이터베이스 테이블과 매핑됩니다. JPQL 쿼리는 이러한 엔티티를 대상으로 데이터를 검색하고 조작합니다.
- **SQL과 비슷한 문법**: JPQL 문법은 SQL과 비슷하며, SELECT, FROM, WHERE, JOIN 등의 SQL 키워드를 사용하여 데이터를 쿼리합니다. 그러나 JPQL은 데이터베이스 테이블과 필드 대신 엔티티 클래스와 엔티티 속성을 참조합니다.
- **타입 안전성**: JPQL 쿼리는 컴파일 시간에 타입 안전성을 제공합니다. 이는 쿼리에서 사용되는 엔티티 및 속성 이름이 올바른지 컴파일러가 검사하므로 런타임 오류를 방지합니다.
- **데이터베이스 독립성**: JPQL은 데이터베이스 종속성을 최소화하며, JPA 구현체가 해당 데이터베이스에 맞는 SQL로 변환합니다. 이로써 애플리케이션은 여러 데이터베이스 시스템 간에 이식성을 유지할 수 있습니다.
- **객체 그래프 탐색**: JPQL을 사용하면 엔티티 간의 관계를 활용하여 객체 그래프를 탐색할 수 있습니다. 이를 통해 복잡한 데이터를 쿼리하고 연결된 객체를 검색할 수 있습니다.
- **쿼리 매개변수**: JPQL은 매개변수를 사용하여 동적 쿼리를 작성할 수 있습니다. 이를 통해 동일한 쿼리를 여러 번 실행하면서 매개변수를 변경하여 데이터를 검색할 수 있습니다.
- JPQL은 JPA와 함께 사용되며, 자바 애플리케이션에서 데이터베이스와 상호 작용하는데 효과적인 방법을 제공합니다.
- JPQL을 사용하면 데이터베이스에 대한 접근을 추상화하고 객체 지향 프로그래밍의 원칙을 유지하면서 데이터를 다룰 수 있습니다.

### 영속성 컨텍스트

- 영속성 컨텍스트(Persistence Context)는 Java Persistence API (JPA)에서 사용되는 중요한 개념 중 하나로, 엔티티(Entity) 객체를 관리하고 데이터베이스와의 상호 작용을 지원하는 핵심 컴포넌트입니다.
- 영속성 컨텍스트는 JPA의 핵심 기능 중 하나로, 데이터베이스와의 데이터를 자바 객체로 매핑하고 관리하는 역할을 합니다.
- **엔티티 관리**: 영속성 컨텍스트는 엔티티 객체를 관리합니다. 이 말은 영속성 컨텍스트 내에서 엔티티 객체를 생성, 수정, 삭제 및 검색할 수 있다는 것을 의미합니다. 이러한 관리를 통해 애플리케이션은 데이터베이스 상호 작용을 추상화하고 객체 지향적으로 데이터를 처리할 수 있습니다.
- **엔티티 상태**: 영속성 컨텍스트 내의 엔티티는 여러 가지 상태를 가질 수 있습니다. 주요 상태는 다음과 같습니다.
    - **새로운 엔티티 (New)**: 데이터베이스에 아직 저장되지 않은 새로운 객체.
    - **영속 엔티티 (Managed)**: 데이터베이스에 저장된 객체로, 영속성 컨텍스트가 관리하는 상태.
    - **준영속 엔티티 (Detached)**: 영속성 컨텍스트로부터 분리된 객체로, 이전에 관리되던 객체가 더 이상 관리되지 않음.
    - **삭제된 엔티티 (Removed)**: 삭제 예정인 객체로, 삭제 후에는 영속성 컨텍스트에서 삭제됨.
- **엔티티 식별**: 각 엔티티는 고유한 식별자(primary key)를 가집니다. 영속성 컨텍스트는 이 식별자를 사용하여 엔티티를 식별하고 관리합니다.
- **캐싱**: 영속성 컨텍스트는 엔티티를 캐싱하여 성능을 향상시킬 수 있습니다. 즉, 같은 엔티티에 대한 반복적인 조회를 데이터베이스에 보내지 않고 영속성 컨텍스트 내에서 데이터를 유지함으로써 데이터베이스 부하를 줄일 수 있습니다.
- **트랜잭션 관리**: 영속성 컨텍스트는 트랜잭션 범위 내에서 엔티티의 상태를 추적합니다. 따라서 트랜잭션이 커밋될 때까지 변경된 엔티티를 데이터베이스에 반영하지 않고 변경 내용을 보류합니다. 이를 통해 데이터 일관성을 유지하면서 효과적으로 변경을 관리할 수 있습니다.
- **지연 로딩(Lazy Loading)**: 영속성 컨텍스트를 사용하면 연관된 엔티티를 필요한 시점에 로드할 수 있습니다. 이를 통해 성능을 최적화하고 불필요한 데이터를 미리 로드하지 않을 수 있습니다.
- **플러시(Flush)**: 영속성 컨텍스트는 변경된 엔티티를 데이터베이스에 동기화하기 위해 플러시 작업을 수행합니다. 플러시는 트랜잭션이나 명시적으로 호출될 때 발생하며, 변경 내용을 데이터베이스에 반영합니다.
- 영속성 컨텍스트는 JPA 구현체에 의해 관리되며, 애플리케이션 코드에서 명시적으로 조작됩니다.
- 엔티티 관리와 데이터베이스 상호 작용을 효율적으로 처리하고 데이터 일관성을 유지하기 위해 영속성 컨텍스트는 중요한 역할을 합니다.

### 엔티티 매핑

- 엔티티 매핑(Entity Mapping)은 Java Persistence API (JPA)에서 사용되는 데이터베이스와 자바 객체 간의 매핑 및 연결을 정의하는 과정입니다.
- 이 과정은 관계형 데이터베이스의 테이블과 열(Column)을 자바 엔티티 클래스와 클래스의 속성에 연결하는 작업을 포함합니다. 엔티티 매핑을 통해 애플리케이션에서 자바 객체를 사용하여 데이터베이스를 조작할 수 있으며, 데이터베이스와 자바 객체 간의 변환을 자동화할 수 있습니다.
- **엔티티 클래스 (Entity Class)**: 엔티티 매핑의 시작점은 자바 클래스를 정의하는 것입니다. 이 클래스를 엔티티 클래스라고 하며, 데이터베이스 테이블과 매핑됩니다. 엔티티 클래스는 JPA 주석(Annotation)을 사용하여 매핑 정보를 제공합니다.
- **JPA 주석**: JPA에서는 주석(Annotation)을 사용하여 엔티티 클래스와 데이터베이스 테이블 간의 매핑을 정의합니다. 주요한 JPA 주석 중 일부는 다음과 같습니다:
    - `@Entity`: 클래스를 JPA 엔티티로 표시합니다.
    - `@Table`: 테이블 이름 및 스키마 등을 설정합니다.
    - `@Id`: 엔티티의 기본 키(primary key)를 설정합니다.
    - `@GeneratedValue`: 기본 키의 자동 생성 전략을 설정합니다.
    - `@Column`: 엔티티의 속성과 데이터베이스 열 간의 매핑을 설정합니다.
    - `@OneToMany`, `@ManyToOne`, `@ManyToMany`: 관계 매핑을 설정합니다.
- **매핑 전략 (Mapping Strategy)**: JPA는 엔티티 클래스와 데이터베이스 테이블 간의 매핑을 위한 다양한 전략을 제공합니다. 주요 매핑 전략으로는 주 테이블 전략, 단일 테이블 전략, 조인 테이블 전략 등이 있으며, 어떤 전략을 선택하느냐에 따라 데이터베이스 스키마와 엔티티 클래스의 구조가 결정됩니다.
- **연관 관계 (Association)**: 엔티티 클래스 간의 관계를 매핑하는 것도 중요합니다. JPA는 단방향 및 양방향 관계를 매핑할 수 있으며, 이를 통해 데이터베이스에서 관계형 데이터를 효과적으로 다룰 수 있습니다.
- **상속 매핑 (Inheritance Mapping)**: 상속 관계에 있는 엔티티 클래스를 매핑할 때, JPA는 상속 전략을 사용하여 데이터베이스 테이블 간의 관계를 정의합니다. 주로 단일 테이블 전략, 조인 테이블 전략, 서브클래스 테이블 전략 등이 사용됩니다.
- **고급 매핑 기능**: JPA는 엔티티 매핑을 보다 세밀하게 제어하기 위한 고급 매핑 기능도 제공합니다. 예를 들어, 열의 삽입 및 갱신 기능을 커스터마이징하거나, 복합 기본 키를 다루거나, 엔티티 생명주기 관리 등이 이에 해당합니다.
- 엔티티 매핑은 JPA를 사용하여 관계형 데이터베이스와 자바 애플리케이션을 통합하는 핵심 부분입니다.
- 올바른 매핑을 통해 데이터의 일관성을 유지하면서 객체 지향 프로그래밍 스타일을 유지할 수 있으며, 데이터베이스와 자바 코드 간의 변환 작업을 자동화할 수 있습니다.

### 연관관계 매핑

- 연관관계 매핑(Association Mapping)은 Java Persistence API (JPA)에서 사용되는 개념으로, 엔티티(Entity) 클래스 간의 관계를 매핑하고 데이터베이스에서 이러한 관계를 표현하는 것을 의미합니다.
- 연관관계 매핑은 데이터베이스에서의 관계를 객체 지향 프로그래밍 관점으로 표현하고 조작할 수 있게 해줍니다.
- 이는 객체 간의 연결 및 관계형 데이터베이스 테이블 간의 외래 키(Foreign Key) 관계와 관련이 있습니다.
- 다양한 매핑
    - 다양한 매핑(Mapping)은 Java Persistence API (JPA)를 사용하여 객체(Object)와 관계형 데이터베이스 간의 매핑 및 연결을 정의하는 과정을 나타냅니다.
    - JPA를 통해 객체와 데이터베이스 간의 매핑을 지원하기 위한 다양한 기술과 방법이 제공됩니다.
    - **엔티티 클래스 매핑(Entity Class Mapping)**:
        - **@Entity**: JPA에서 엔티티 클래스를 정의할 때 사용하는 주석입니다. 이 주석을 통해 해당 클래스가 JPA 엔티티임을 표시합니다.
        - **@Table**: 엔티티 클래스와 데이터베이스 테이블 간의 매핑을 지정하는 주석입니다. 테이블 이름, 스키마 등을 설정할 수 있습니다.
    - **필드 매핑(Field Mapping)**:
        - **@Id**: 엔티티 클래스의 기본 키(primary key)를 지정하는 주석입니다.
        - **@GeneratedValue**: 기본 키 값의 자동 생성 전략을 설정하는 주석입니다. 주로 자동 증가(auto-increment) 형식을 사용합니다.
        - **@Column**: 엔티티 클래스의 속성과 데이터베이스 열 간의 매핑을 정의하는 주석입니다. 열 이름, 길이, 제약 조건 등을 설정할 수 있습니다.
    - **연관 관계 매핑(Association Mapping)**:
        - **@OneToOne**: 일대일 관계를 매핑합니다. 예를 들어, 사용자(User) 엔티티와 프로필(Profile) 엔티티 간의 관계를 나타낼 수 있습니다.
        - **@OneToMany** 및 **@ManyToOne**: 일대다 및 다대일 관계를 매핑합니다. 한 엔티티가 다른 엔티티를 여러 개 가질 수 있는 경우에 사용합니다.
        - **@ManyToMany**: 다대다 관계를 매핑합니다. 예를 들어, 학생(Student)과 과목(Subject) 간의 다대다 관계를 나타낼 수 있습니다.
    - **상속 매핑(Inheritance Mapping)**:
        - **@Inheritance**: 상속 관계를 매핑하기 위해 사용되며, 상속 전략을 선택할 수 있습니다. 주로 단일 테이블 전략, 조인 테이블 전략, 서브클래스 테이블 전략이 사용됩니다.
        - **@DiscriminatorColumn**: 상속 전략에서 사용되며, 서브클래스를 식별하는 데 사용할 열을 지정합니다.
        - **@DiscriminatorValue**: 서브클래스의 구분 값을 지정합니다.
    - **LOB(대형 객체) 매핑(LOB Mapping)**:
        - **@Lob**: 대형 객체(이미지, 텍스트, 바이너리 데이터 등)를 매핑하는 주석입니다. 데이터베이스에 큰 데이터를 저장할 때 사용됩니다.
    - **날짜 및 시간 타입 매핑(Date and Time Type Mapping)**:
        - **@Temporal**: 엔티티 클래스의 날짜 및 시간 타입 필드를 매핑할 때 사용됩니다. DATE, TIME, TIMESTAMP 등의 타입을 설정할 수 있습니다.
    - **열 열거형(Enum Mapping)**:
        - **@Enumerated**: Java 열거형(Enum) 타입을 데이터베이스 열로 매핑할 때 사용됩니다.
    - **고급 매핑(Advanced Mapping)**:
        - **@Embeddable** 및 **@Embedded**: 복합 객체를 매핑할 때 사용됩니다. 예를 들어, 주소(Address)와 같은 객체를 엔티티 클래스에 포함할 수 있습니다.
        - **@ElementCollection**: 컬렉션 타입(List, Set, Map 등)의 요소를 매핑할 때 사용됩니다.
        - **@Convert**: 엔티티 클래스의 속성을 데이터베이스 열과 자동으로 변환하기 위해 사용됩니다. 사용자 정의 변환기를 지정할 수 있습니다.
    - 이러한 다양한 매핑 기술을 사용하여 JPA 엔티티 클래스를 정의하고 데이터베이스와 연동하는 데 필요한 매핑 설정을 구성할 수 있습니다.
    - 이를 통해 데이터베이스와 자바 객체 간의 매핑 및 상호 작용을 지원하며, 객체 지향 프로그래밍 스타일을 유지하면서 데이터베이스와의 통합을 달성할 수 있습니다.
- 연관관계 매핑
    - 연관관계 매핑에서, 엔티티(Entity) 클래스 간의 관계를 매핑할 때 단방향과 양방향 관계가 있습니다. 이 두 가지 유형은 객체 간의 관계를 표현하고 다루는 방식을 나타냅니다.
    - **단방향 관계 (Unidirectional Relationship)**:
        - **정의**: 단방향 관계는 한 엔티티 클래스에서 다른 엔티티 클래스로의 관계를 정의한 것입니다. 이 관계를 통해 한 방향으로만 데이터를 검색하거나 조작할 수 있습니다.
        - **예시**: "도서" 엔티티 클래스에서 "저자" 엔티티 클래스로의 참조를 설정한 경우, "도서" 엔티티는 "저자" 엔티티를 참조할 수 있지만 그 역은 성립하지 않습니다.
        - **단점**: 역방향으로 탐색할 수 없기 때문에 해당 방향으로만 데이터를 조회하고 변경해야 합니다.
    - **양방향 관계 (Bidirectional Relationship)**:
        - **정의**: 양방향 관계는 두 엔티티 클래스 간의 관계를 양쪽 방향으로 정의하는 것입니다. 즉, 한 엔티티 클래스에서 다른 엔티티 클래스로의 관계를 설정하고, 반대 엔티티 클래스에서도 그 역방향 관계를 설정합니다.
        - **예시**: "도서" 엔티티 클래스에서 "저자" 엔티티 클래스로의 참조를 설정하고, 동시에 "저자" 엔티티 클래스에서 "도서" 엔티티 클래스로의 참조를 설정하면 양방향 관계가 형성됩니다.
        - **장점**: 양방향 관계를 사용하면 두 엔티티 클래스 모두에서 상호적으로 데이터를 조회하고 변경할 수 있습니다. 또한, 효율적인 쿼리 작성과 더 많은 제어를 가능하게 합니다.
        - **주의**: 양방향 관계를 설정할 때, 관계의 주인(Owner)을 명확히 지정해야 합니다. 관계의 주인은 역방향 관계를 관리하고 업데이트하는 엔티티입니다.
    - 단방향과 양방향 관계 모두 데이터 모델링 및 애플리케이션 요구 사항에 따라 선택됩니다.
    - 단방향 관계는 간단하고 단순한 경우에 적합하며, 양방향 관계는 두 엔티티 간의 상호 작용이 필요한 경우나 특수한 쿼리 작성이 필요한 경우에 유용합니다.
    - 양방향 관계를 정의할 때는 관계의 주인을 명확하게 정의하고 관리하는 것이 중요합니다.

### Spring Data JPA

- Spring Data JPA는 스프링(Spring) 기반의 애플리케이션에서 Java Persistence API (JPA)를 더 쉽게 사용하고 관리할 수 있도록 도와주는 프레임워크입니다.
- Spring Data JPA는 JPA를 기반으로 하며, 데이터베이스와의 상호 작용을 추상화하고 반복적인 데이터 액세스 코드를 줄이는 데 도움을 줍니다.
- **JPA와의 통합**: Spring Data JPA는 스프링과 JPA를 효율적으로 통합하며, 스프링 애플리케이션 내에서 JPA 엔티티와 레포지토리를 정의하고 사용할 수 있도록 지원합니다.
- **Repository 인터페이스**: Spring Data JPA에서 데이터베이스 액세스를 위한 리포지토리 인터페이스를 정의할 수 있습니다. 이 인터페이스는 CRUD(Create, Read, Update, Delete) 작업을 수행하는 메서드를 선언하며, 사용자가 직접 구현하지 않고 스프링이 자동으로 구현체를 생성합니다.
- **쿼리 메서드**: 스프링 Data JPA는 메서드 이름을 분석하여 JPA 쿼리를 자동으로 생성하는 기능을 제공합니다. 이를 통해 복잡한 쿼리를 작성하지 않고도 데이터베이스에 접근할 수 있습니다.
- **NamedQuery 지원**: NamedQuery를 사용하여 미리 정의된 JPA 쿼리를 사용할 수 있으며, 리포지토리 메서드에 정의된 쿼리와 함께 사용할 수 있습니다.
- **Specification과 QueryDSL**: Spring Data JPA는 Specification 및 QueryDSL과 같은 고급 쿼리 작성 도구를 지원하여 복잡한 쿼리를 더 쉽게 작성하고 조합할 수 있습니다.
- **Auditing**: 엔티티의 생성 및 수정 시간을 자동으로 관리하도록 지원합니다. `@CreatedDate`, `@LastModifiedDate` 어노테이션을 사용하여 이 기능을 활성화할 수 있습니다.
- **Pagination 및 Sorting**: 페이징 및 정렬을 위한 메서드를 제공하여 대용량 데이터의 효율적인 처리를 지원합니다.
- **Flush와 Batch 처리**: JPA의 영속성 컨텍스트를 효과적으로 관리하며, flush 모드 설정 및 배치 처리를 지원합니다.
- **다양한 데이터베이스 지원**: Spring Data JPA는 다양한 데이터베이스를 지원하며, 데이터베이스 별로 필요한 설정을 제공합니다.
- **Spring Boot와 통합**: Spring Boot 애플리케이션과 함께 사용하면 더욱 편리하게 Spring Data JPA를 설정하고 실행할 수 있습니다.
- Spring Data JPA를 사용하면 데이터베이스 액세스 코드를 최소화하고 데이터베이스와의 상호 작용을 더 추상화할 수 있으므로 개발 생산성을 향상시키고 코드 유지보수를 단순화할 수 있습니다.
- 이를 통해 애플리케이션 개발에 보다 집중할 수 있게 됩니다.