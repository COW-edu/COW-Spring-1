# JAVA 사전과제

### 자바의 데이터 타입에 대해 작성해주세요.(Primitive vs Reference)

- 프로그램은 자료구조와 알고리즘의 결합으로 이루어진다.
- 프로그램이란 자료구조를 통해 데이터를 구성하고 표현하며 알고리즘을 통해 문제를 해결한다.
- 데이터 표현의 방법은 프로그램의 많은 영향을 주게 되는데 이는 문제를 해결하는 방법 알고리즘이 데이터의 표현에 따라서 달라지기 때문이다.
- 데이터를 얼마나 잘 다루느냐가 좋은 프로그램을 작성할 수 있는 관건이 된다.
- Java의 데이터 타입에는 크게 기본타입(primitive type)과 참조타입(reference type)으로 분류된다.
- 기본타입(primitive type)
    - 정수, 실수, 문자, 논리 리터럴을 저장하는 타입을 말한다.
    - 정수 타입에는 `byte`, `char`, `short`, `int`, `long`이 있고, 실수 타입에는 `float`, `double`이 있다.
    - 논리 타임에는 `boolean`이 있다.
    - 메모리에는 0과 1을 저장하는 최소 기억 단위인 비트(`bit`)가 있다.
    - 8개의 비트를 묶어서 바이트(`byte`)라고 한다.
    - 기본 타입은 정해진 메모리 사용 크기로 값을 정하는데 바이트 크기가 클수록 표현하는 값의 범위가 크다.
    - 변수가 사용할 수 있는 값의 범위를 초과하게 되면 오버플로우(overflow)현상이 발생한다.
    - 변수에서 오버플로우 현상이 발생하게 되면 원하지 않는 엉뚱한 값이 변수에 들어가게 된다.
- 참조타입(reference type)
    - 참조 타입은 객체의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스 타입을 말한다.
    - 기본 타입과 참조 타입의 차이는 저장되는 값이 무엇인가 이다.
    - 기본 타입으로 선언된 변수는 실제 값을 변수에 저장하지만 참조 타입은 배열, 열거, 클래스, 인터페이스를 이용하여 선언된 변수는 메모리에 번지를 값으로 갖게 된다.
    - 기본 데이터 타입과 참조 타입은 데이터가 생성되고 저장되는 위치가 다르다.
    - 기본 데이터 타입은 스택 영역에 생성이 되고 참조 데이터 타입은 힙 영역에 생성이 된다.

### **자바의 접근제어자에 대해 작성해주세요.**

- 접근 제어자
    - 접근제어자는 멤버 또는 클래스에 사용되어 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.
    - 접근제어자는 생략가능하며 생략했을 때는 자동으로 `default` 임을 뜻하게 된다.
    - `default` 일경우에는 접근제어자를 지정하지 않는다.
    - 접근제어자가 사용될 수 있는 곳은 클래스, 멤버변수, 메서드, 생성자이다.
    - `private` : 같은 클래스 내에서만 접근 가능하다.
    - `default` : 같은 패키지 내에서만 접근 가능하다.
    - `protected` : 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능하다.
    - `public` : 접근 제한이 전혀 없다.
- 접근 제어자를 이용한 캡슐화
    - 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다.
    - 데이터가 유효한 값을 유지하도록 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제한하는 것이 필요하다.
    - 데이터 감추기라고 하며 객체지향개념에선 `캡슐화(encapsulation)`라고 한다.

### **static 키워드에 대해 작성해주세요.**

- static
    - `Java`에서 `Static`키워드를 사용한다는 것은 메모리에 한번 할당되어 프로그램이 종료될 때 해제되는 것을 의미한다.
    - 일반적으로 우리가 만든 `Class`는 `Static`영역에 생성되고, `new`연산을 통해 생성한 객체는 `Heap`영역에 생성된다.
    - 객체의 생성시에 할당된 `Heap`영역의 메모리는 `Garbage Collector`를 통해 수시로 관리를 받는다.
    - `Static`키워드를 통해 `Static`영역에 할당된 메모리는 모든 객체가 공유하는 메모리라는 장점을 지니지만, `Garbage Collector`의 관리 영역 밖에 존재하므로 `Static`을 자주 사용하면 프로그램의 종료시까지 메모리가 할당된 채로 존재하므로 자주 사용하게 되면 시스템의 퍼포먼스에 악영향을 주게 된다.
    - `Static`변수는 클래스 변수이다.
    - 객체를 생성하지 않고도 `Static`자원에 접근이 가능하다.
- static변수(정적변수)
    - `Java`에서 `Static`변수는 메모리에 한번 할당되어 프로그램이 종료될 때 해제되는 변수로, 메모리에 한번 할당되므로 여러 객체가 해당 메모리를 공유하게 된다.
    - 일반적으로 `Static`은 상수의 값을 갖는 경우가 많으므로 `public`으로 선언을 하여 사용한다.
    - 일반적으로 `static`변수는 `public`및 `final`과 함께 사용되어 `public static final`로 활용된다.
- static메소드(정적메소드)
    - `Static Method`는 객체의 생성 없이 호출이 가능하며, 객체에서는 호출이 가능은 하지만 지양하고 있다.
    - 일반적으로는 유틸리티 관련 함수들은 여러 번 사용되므로 `static`메소드로 구현을 하는 것이 적합한데, `static`메소드를 사용하는 대표적인 `Util Class`로는 `java.util.Math`가 있다.

### **final 키워드에 대해 작성해주세요.**

- final
    - 자바언어에서 `final`은 오직 한 번만 할당할 수 있는 `entity`를 정의할 때 사용된다.
    - `final`로 선언된 변수가 할당되면 항상 같은 값을 가진다.
    - 만약 `final`변수가 객체를 참조하고 있다면, 그 객체의 상태가 바뀌어도 `final`변수는 매번 동일한 내용을 참조한다.
- final 클래스
    - `final`이 붙어있는 클래스는 상속할 수 없다.
    - 보안이나 효율성 측면에서 장점이 잇다.
    - `java.lang.System`이나 `java.lang.String`처럼 자바에서 기본적으로 제공하는 라이브러리 클래스는 `final`을 사용한다.
- final 메소드
    - 어떤 클래스를 상속하는데 그 안에 `final`메소드가 있다면, 오버라이딩으로 수정할 수 없다.
- final 변수
    - `final`변수는 한 번 값을 할당하면 수정할 수 없다.
    - 초기화는 한 번만 가능하다.
    - 먼저 선언하고 각각 다른 값을 갖도록 초기화 할 수도 있다.
    - 하지만 이렇게 한 번 값을 할당하면 다음부터는 수정할 수 없다.
    - 이런 형태를 `blank final` 변수라고 한다.

### **오버로딩(overloading)과 오버라이딩(overriding)에 대해 작성해주세요.**

- 오버로딩(Overloading)
    - `오버로딩(overloading)`이라는 뜻은 사전적으로 '과적하다.'라는 뜻이다.
    - C언어에서는 함수명이 고유하게 존재해야 한다.
    - 하나의 함수가 하나의 기능만을 구현해야 한다는 것이다.
    - 하지만 자바에서는 하나의 메소드 이름으로 여러 기능을 구현하기 때문에 '과적하다.'라는 뜻의 이름을 붙여준 것으로 보인다.
    - 오버로딩은 자바의 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메소드를 정의할 수 있다.
    - 조건
        - 메소드의 이름이 같고, 매개변수의 개수나 타입이 달라야한다.
        - 주의할 점은 리턴값만 다른것은 오버로딩 할 수 없다는 것이다.
        - 또한 접근 제어자도 자유롭게 지정해 줄 수 있다.
        - 각 메소드의 접근 제어자를 `public`, `default`, `protected`, `private`으로 다르게 지정해줘도 상관없다.
        - 접근 제어자만 다르게한다고 오버로딩이 가능하지는 않다.
        - 오버로딩은 매개변수의 차이로만 구현할 수 있다.
        - 매개변수가 다르다면 리턴 값은 다르게 지정할 수 있다.
    - 사용하는 이유
        - 같은 기능을 하는 메소드를 하나의 이름으로 사용할 수 있다.
            - 흔히 콘솔창에 텍스트를 출력할 때 사용하는 `println`라는 메소드를 대표적인 예로 들어볼 수 있다.
            - `println`의 인자 값으로 `int`, `double`, `boolean`, `String`등의 아주 다양한 타입의 매개변수들을 집어넣어도 콘솔창에 아주 잘 출력해주는 것을 볼 수 있다.
            - 이렇게 `'출력하다'`라는 같은 기능을 가진 메소드들를 `println`이라는 하나의 이름으로 정의가 가능한 것이다.
        - 메소드의 이름을 절약할 수 있다.
            - `println`메소드를 매개변수의 종류에 따라서 다르게 지정한다면 `printlnInt`, `printlnDouble`, `printlnBoolean`등 수많은 메소드들의 이름을 정해줘야 할 것이다.
            - 이는 프로그래머의 입장에서는 메소드의 네이밍에 고민을 가중시킨다.
            - 그리고 이런 이름들은 다른 곳에 사용할 가능성도 생기게 된다.
- 오버라이딩(overriding)
    - 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하는 것을 오버라이딩이라고 한다.
    - 상속받은 메소드를 그대로 사용할 수도 있지만, 자식 클래스에서 상황에 맞게 변경해야하는 경우 오버라이딩할 필요가 생긴다.
    - 조건
        - 오버라이딩은 부모 클래스의 메소드를 재정의하는 것이므로, 자식 클래스에서는 오버라이딩하고자 하는 메소드의 이름, 매개변수, 리턴 값이 모두 같아야 한다.
- @Override
    - 어노테이션(`Annotation`)이라는 것으로 직역하면 주석이라는 뜻이다.
    - 일반적인 주석과 다르게, 검증하는 기능을 한다.
    - `@Override`라는 어노테이션은 오버라이딩을 검증하는 기능을 한다.
    - 코드상으로 검사했을 때 오버라이딩이 실제로 시행되지 않았다면 컴파일시 오류를 출력한다.
    - 부모 클래스의 메소드를 오버라이딩하는 것은 내용만을 새로 정의하는 것이므로 선언부는 부모의 것과 완벽히 동일해야 한다.
    - 접근 제어자를 다르게 설정해 놓은 것을 볼 수 있다.
    - 오버라이딩에서 접근 제어자를 설정하는 규칙이 존재한다.
    - 자식 클래스에서 오버라이딩하는 메소드의 접근 제어자는 부모 클래스보다 더 좁게 설정할 수 없다.
        - 부모클래스의 접근제어자는 `default`로 설정되어 있다.
        - 여기서 자식 클래스들은 `default`보다 같거나 더 넓은 범위의 접근제어자만 설정할 수 있으므로 `default`, `protected`, `public`이 세 개의 접근 제어자는 사용이 가능하다.
    - `예외(Exception)`는 부모 클래스의 메소드 보다 많이 선언할 수 없다.
        - 부모 클래스에서 어떤 예외를 `throws`한다고 하면, 자식 클래스에서는 그 예외보다 더 큰 범위의 예외를 `throws`할 수 없다는 것이다.
    - `static`메소드를 인스턴스의 메소드로 또는 그 반대로 바꿀 수 없다.
        - 부모 클래스의 `static`메소드를 자식에서 같은 이름으로 정의할 수 있지만 이것은 다시 정의하는 것이 아니라 같은 이름의 `static`메소드를 새로 정의하는 것이다.

### **추상 클래스와 인터페이스의 차이를 작성해주세요.**

- 추상 클래스
    - 추상클래스는 일반 클래스와 비슷하지만, 추상 메서드를 선언하여 상속을 통해서 자손 클래스에서 완성하도록 유도하는 클래스이다.
    - 미완성 설계도라고도 표현한다.
    - 상속을 위한 클래스이기 때문에 따로 객체를 생성할 수 없다.
    - `class`앞에 `abstract` 예약어를 사용하여 상속을 통해서 구현해야한다는 것을 알려주고 선언부만 작성하는 추상메서드를 선언할 수 있다.
- 인터페이스
    - 추상클래스가 미완성 설계도라면 인터페이스는 기본 설계도라고 할 수 있다.
    - 인터페이스도 추상클래스처럼 다른 클래스를 작성하는데 도움을 주는 목적으로 작성하고 클래스와 다르게 다중상속(구현)이 가능하다.
- 비교
    - 공통점은 메서드의 선언만 있고, 구현 내용이 없다는 것이다. (추상 메서드)
    - `new`키워드를 통해 객체를 생성할 수 없으며, 상속받은 클래스가 반드시 선언된 추상 메서드를 구현하도록 한다는 것이다.
    - 차이점으로는 추상 클래스는 `extends`키워드를 사용하여 상속하며, 다중 상속은 불가능하다.
    - 반면 인터페이스는 `implements`키워드를 사용하여 상속하며, 다중 상속이 가능하다.
    - 추상 클래스는 일반 변수, 생성자, 일반 메서드, 추상 메서드를 모두 가질 수 있는 반면 인터페이스는 상수와 추상 메서드만 가질 수 있고, 생성자와 일반 변수는 가질 수 없다.
    - 개념적 차이점이 아닌 실제 적용하는 것에서 차이점을 생각해보면, 추상 클래스는 `extends`(상속, 확장의 느낌) 키워드 그대로 자신의 기능들을 하위로 확장시키는 것으로 볼 수 있다.
    - 인터페이스는 `implements`(상속, 구현의 느낌) 키워드처럼 인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 동일한 기능으로 구현하는 것으로 볼 수 있다.

### **Enum에 대해 작성해주세요.**

- `Enumeration`은 프로그래밍언어에서 상수의 그룹을 나타낼 때 사용한다.
- `Enum`은 컴파일 당시 우리가 모든 가능한 값을 알고있는 경우 사용된다.
- 항상 `enum`안의 상수는 타입이 정해져 있어야 되는 것은 아니다.
- Java 1.5버전 부터, `enum`은 `enum`데이터 타입이라고 표시되었다.
- 자바 `enum`은 C/C++ `enum`보다 더 강력한 기능을 제공한다.
- 자바에서 변수, 메소드 그리고 생성자를 추가할 수 있다.
- `enum`의 주된 목적은 우리만의 데이터 타입을 가지기 위해서이다.

### **Generic에 대해 작성해주세요.**

- 자바에서 제네릭(`generic`)이란 데이터의 타입(`data type`)을 일반화한다(generalize)는 것을 의미한다.
- 제네릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법이다.
- 컴파일 시에 미리 타입 검사(`type check`)를 수행하면 다음과 같은 장점을 가진다.
    - 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있다.
    - 반환값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있다.
    - 제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.
    - 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다. 즉, 관리하기가 편하다.
    - 비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.

### **람다에 대해 작성해주세요.**

- 람다 함수는 프로그래밍 언어에서 사용되는 개념으로 익명 함수(Anonymous functions)를 지칭하는 용어이다.
- 현재 사용되고 있는 람다의 근간은 수학과 기초 컴퓨터과학 분야에서의 람다 대수이다.
- 람다 대수는 간단히 말하자면 수학에서 사용하는 함수를 보다 단순하게 표현하는 방법이다.
- 람다 대수는 이름을 가질 필요가 없다. - 익명 함수 (Anonymous functions)
- 두 개 이상의 입력이 있는 함수는 최종적으로 1개의 입력만 받는 람다 대수로 단순화 될 수 있다. - 커링 (Curring)
- 익명함수란 말그대로 함수의 이름이 없는 함수이다.
- 익명함수들은 공통으로 ****일급객체(First Class citizen)라는 특징을 가지고 있다.
- 일급 객체란 일반적으로 다를 객체들에 적용 가능한 연산을 모두 지원하는 개체를 가르킨다.
- 함수를 값으로 사용 할 수도 있으며 파라메터로 전달 및 변수에 대입 하기와 같은 연산들이 가능하다.
- 장점
    - 코드의 간결성 - 람다를 사용하면 불필요한 반복문의 삭제가 가능하며 복잡한 식을 단순하게 표현할 수 있다.
    - 지연연산 수행 - 람다는 지연연상을 수행 함으로써 불필요한 연산을 최소화 할 수 있다.
    - 병렬처리 가능 - 멀티쓰레디를 활용하여 병렬처리를 사용 할 수 있다.
- 단점
    - 람다식의 호출이 까다롭다.
    - 람다 `stream`사용 시 단순 `for문` 혹은  `while문` 사용 시 성능이 떨어진다
    - 불필요하게 너무 사용하게 되면 오히려 가독성을 떨어 뜨릴 수 있다.
- 표현식
    - 람다는 매개변수 화살표(`->`) 함수몸체로 이용하여 사용 할 수 있다.
    - 함수몸체가 단일 실행문이면 괄호{}를 생략 할 수 있다.
    - 함수몸체가 `return`문으로만 구성되어 있는 경우 괄호`{}`를 생략 할 수 없다.